{"version":3,"file":"index.js","sources":["../src/env.js","../src/imports.js","../src/strings.js","../src/parser.js","../src/type-checker.js","../src/args.js","../src/fixer.js","../src/interactions.js"],"sourcesContent":["/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { config } from \"@onflow/config\";\n\nexport const DEPLOYED_CONTRACTS = {\n  emulator: {\n    FlowToken: \"0xee82856bf20e2aa6\",\n    FungibleToken: \"0x0ae53cb6e3f42a79\",\n  },\n  testnet: {\n    FlowToken: \"0x7e60df042a9c0868\",\n    FungibleToken: \"0x9a0766d93b6608b7\",\n    LockedTokens: \"0x95e019a17d0e23d7\",\n    StakingProxy: \"0x7aad92e5a0715d21\",\n  },\n  mainnet: {\n    FlowToken: \"0x1654653399040a61\",\n    FungibleToken: \"0xf233dcee88fe0abe\",\n    LockedTokens: \"0x8d0e87b65159ae63\",\n    StakingProxy: \"0x62430cf28c26d095\",\n  },\n};\n\nexport const ACCESS_NODES = {\n  mainnet: \"https://access.mainnet.onflow.org\",\n  testnet: \"https://access-testnet.onflow.org\",\n  emulator: \"http://localhost:8080\",\n};\n\nexport const getEnvironment = async () => {\n  const env = (await config().get(\"ix.env\")) || \"emulator\";\n  return DEPLOYED_CONTRACTS[env] || DEPLOYED_CONTRACTS.emulator;\n};\n\nexport const setEnvironment = async (networkName = \"emulator\", options = {}) => {\n  const network = networkName.toLowerCase();\n\n  if (!DEPLOYED_CONTRACTS[network]) {\n    throw new Error(\n      `Provided value \"${network}\" is not supported. Try \"emulator\", \"testnet\" or \"mainnet\". Default: \"emulator\"`\n    );\n  }\n\n  const { port, endpoint } = options;\n  const portBased =\n    network === \"emulator\" && port ? `http://localhost:${port}` : ACCESS_NODES[network];\n  const accessNode = endpoint || portBased;\n\n  await config().put(\"ix.env\", network);\n  await config().put(\"accessNode.api\", accessNode);\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst getPairs = (line) => {\n  return line\n    .split(/\\s/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item.length > 0 && item !== \"import\" && item !== \"from\");\n};\n\nconst collect = (acc, item) => {\n  const [contract, address] = item;\n  acc[contract] = address;\n  return acc;\n};\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = (code) => {\n  if (!code || code.length === 0) {\n    return {};\n  }\n  return code\n    .split(\"\\n\")\n    .filter((line) => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {});\n};\n\n/**\n * Returns list of missing imports.\n * @param {string} code - template cadence code\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n */\nexport const missingImports = (code, addressMap = {}) => {\n  const importsList = extractImports(code);\n  const missing = [];\n\n  for (const key in importsList) {\n    if (!addressMap[key] && Object.prototype.hasOwnProperty.call(importsList, key)) {\n      missing.push(key);\n    }\n  }\n\n  return missing;\n};\n\n/**\n * Reports missing imports.\n * @param {Array.<string>} list - list of missing imports\n * @param {string} prefix - error message prefix\n */\nexport const report = (list = [], prefix = \"\") => {\n  const errorMessage = `Missing imports for contracts:`;\n  const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n  console.error(message, list);\n};\n\n/**\n * Reports missing imports.\n * @param {string} code - template cadence code\n * @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n * @param {string} [prefix] - prefix to add to error message\n */\nexport const reportMissingImports = (code, addressMap, prefix = \"\") => {\n  const list = missingImports(code, addressMap);\n  if (list.length > 0) {\n    report(list, prefix);\n  }\n};\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g;\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address;\n    const newAddress = addressMap instanceof Function ? addressMap(key) : addressMap[key];\n\n    // If the address is not inside addressMap we shall not alter import statement\n    const validAddress = newAddress || address;\n    return `${imp}${contract} from ${validAddress}`;\n  });\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const capitalizeFirstLetter = (input) => {\n  const [first] = input.split(\"\");\n  return first.toUpperCase() + input.slice(1);\n};\n\nexport const underscoreToCamelCase = (text) => {\n  return text\n    .replace(/-/g, \"_\")\n    .split(\"_\")\n    .map((word, i) => (i > 0 ? capitalizeFirstLetter(word) : word))\n    .join(\"\");\n};\n\nexport const trimAndSplit = (input, trimWith, splitBy) => {\n  if (splitBy) {\n    return input.replace(trimWith, \"\").split(splitBy);\n  }\n  return input.replace(trimWith, \"\").split(getSplitCharacter(input));\n};\n\nexport const getSplitCharacter = (input) => {\n  switch (true) {\n    case input.indexOf(\"//\") >= 0:\n      return \"//\";\n    case input.indexOf(\"/\") >= 0:\n      return \"/\";\n    case input.indexOf(\"\\\\\") >= 0:\n      return \"\\\\\";\n    default:\n      return \"\";\n  }\n};\n\nexport const collapseSpaces = (input) => input.replace(/\\s+/g, \" \");\nexport const removeSpaces = (input) => input.replace(/\\s+/g, \"\");\nexport const stripNewLines = (input) => input.replace(/\\r\\n|\\n|\\r/g, \" \");\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { collapseSpaces } from \"./strings\";\n\nexport const CONTRACT = \"contract\";\nexport const TRANSACTION = \"transaction\";\nexport const SCRIPT = \"script\";\nexport const UNKNOWN = \"unknown\";\n\nexport const generateSchema = (argsDefinition) =>\n  argsDefinition\n    .split(\",\")\n    .map((item) => item.replace(/\\s*/g, \"\"))\n    .filter((item) => item !== \"\");\n\nexport const extract = (code, keyWord) => {\n  const target = collapseSpaces(code.replace(/[\\n\\r]/g, \"\"));\n\n  if (target) {\n    const regexp = new RegExp(keyWord, \"g\");\n    const match = regexp.exec(target);\n\n    if (match) {\n      if (match[1] === \"\") {\n        return [];\n      }\n      return generateSchema(match[1]);\n    }\n  }\n  return [];\n};\n\nexport const extractSigners = (code) => {\n  return extract(code, `(?:prepare\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractScriptArguments = (code) => {\n  return extract(code, `(?:fun\\\\s+main\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractTransactionArguments = (code) => {\n  return extract(code, `(?:transaction\\\\s*\\\\(\\\\s*)([^\\\\)]*)(?:\\\\))`);\n};\n\nexport const extractContractName = (code) => {\n  const contractNameMatcher = /\\w+\\s+contract\\s+(?:interface)*\\s*(\\w*)/g;\n  const singleLine = code.replace(/\\r\\n|\\n|\\r/g, \" \");\n  const matches = contractNameMatcher.exec(singleLine);\n\n  if (matches.length < 2) {\n    throw new Error(\"Contract Error: can't find name of the contract\");\n  }\n\n  return matches[1];\n};\n\nexport const extractContractParameters = (code) => {\n  const complexMatcher = /(resource|struct)\\s+\\w+\\s*{[\\s\\S]+?}/g;\n  const contractNameMatcher =\n    /\\w+\\s+contract\\s+(?:interface)*\\s*(\\w*)(\\s*{[.\\s\\S]*init\\s*\\((.*?)\\)[.\\s\\S]*})?/g;\n  const clean = code.replace(complexMatcher, \"\");\n  const matches = contractNameMatcher.exec(clean);\n\n  if (matches.length < 2) {\n    throw new Error(\"Contract Error: can't find name of the contract\");\n  }\n\n  return {\n    contractName: matches[1],\n    args: matches[3] || \"\",\n  };\n};\n\nexport const getTemplateInfo = (code) => {\n  const contractMatcher = /\\w+\\s+contract\\s+(\\w*\\s*)\\w*/g;\n  const transactionMatcher = /transaction\\s*(\\(\\s*\\))*\\s*/g;\n  const scriptMatcher = /pub\\s+fun\\s+main\\s*/g;\n\n  if (transactionMatcher.test(code)) {\n    const signers = extractSigners(code);\n    const args = extractTransactionArguments(code);\n    return {\n      type: TRANSACTION,\n      signers: signers.length,\n      args: args,\n    };\n  }\n\n  if (scriptMatcher.test(code)) {\n    const args = extractScriptArguments(code);\n    return {\n      type: SCRIPT,\n      args: args,\n    };\n  }\n\n  if (contractMatcher.test(code)) {\n    // TODO: implement extraction from `init` method\n    const { contractName, args } = extractContractParameters(code);\n    return {\n      type: CONTRACT,\n      signers: 1,\n      args,\n      contractName,\n    };\n  }\n\n  return {\n    type: UNKNOWN,\n  };\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const wrongType = (type) => !type || typeof type != \"string\";\n\nexport const isBasicNumType = (type) => {\n  if (wrongType(type)) return false;\n  return type.startsWith(\"Int\") || type.startsWith(\"UInt\") || type.startsWith(\"Word\");\n};\n\nexport const isFixedNumType = (type) => {\n  if (wrongType(type)) return false;\n  return type.startsWith(\"Fix64\") || type.startsWith(\"UFix64\");\n};\n\nexport const isString = (type) => type === \"String\";\nexport const isCharacter = (type) => type === \"Character\";\nexport const isBoolean = (type) => type === \"Bool\";\nexport const isAddress = (type) => type === \"Address\" || type === \"Address?\";\n\nexport const isBasicType = (type) => {\n  if (wrongType(type)) return false;\n\n  let fixedType = type.endsWith(\"?\") ? type.slice(0, -1) : type;\n  return (\n    isBasicNumType(fixedType) ||\n    isString(fixedType) ||\n    isCharacter(fixedType) ||\n    isBoolean(fixedType)\n  );\n};\n\nexport const isArray = (type) => {\n  if (wrongType(type)) return false;\n\n  const clearType = type.replace(/\\s/g, \"\");\n  return clearType.startsWith(\"[\") && clearType.endsWith(\"]\");\n};\n\nexport const isDictionary = (type) => {\n  if (wrongType(type)) return false;\n\n  const clearType = type.replace(/\\s/g, \"\");\n  return clearType.startsWith(\"{\") && clearType.endsWith(\"}\");\n};\n\nexport const isComplexType = (type) => isArray(type) || isDictionary(type);\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as t from \"@onflow/types\";\nimport * as fcl from \"@onflow/fcl\";\n\nimport { toFixedValue, withPrefix } from \"./fixer\";\nimport { getTemplateInfo } from \"./parser\";\nimport {\n  isBasicType,\n  isFixedNumType,\n  isAddress,\n  isArray,\n  isDictionary,\n  isComplexType,\n  wrongType, isBasicNumType,\n} from \"./type-checker\";\n\nimport { removeSpaces } from \"./strings\";\n\nconst throwTypeError = (msg) => {\n  throw new Error(\"Type Error: \" + msg);\n};\n\nexport const splitArgs = (pair) => {\n  return pair\n    .split(/(\\w+)\\s*:\\s*([\\w{}[\\]:\\s?]*)/)\n    .filter((item) => item !== \"\")\n    .map((item) => item.replace(/\\s*/g, \"\"));\n};\n\nexport const argType = (pair) => splitArgs(pair)[1];\n\nexport const getDictionaryTypes = (type) => {\n  const match = /{(.*)}/.exec(type);\n  return match[1]\n    .split(/([^:]*):(.*)/)\n    .map((item) => item.replace(/\\s/g, \"\"))\n    .filter((item) => item);\n};\n\nexport const getArrayType = (type) => {\n  const match = /\\[(.*)\\]/.exec(type);\n  return removeSpaces(match[1]);\n};\n\n/**\n * Reports missing arguments.\n * @param {number} found - number of arguments passed into method\n * @param {number} required - number of arguments required to execute the code\n * @param {string} prefix - error message prefix\n */\nexport const reportArguments = (found, required, prefix = \"\") => {\n  if (required > found) {\n    const errorMessage = `Incorrect number of arguments: found ${found} of ${required}`;\n    const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n    console.error(message);\n  }\n};\n\n/**\n * Reports missing items.\n * @param {string} itemType - name of the missing item\n * @param {number} found - number of arguments passed into method\n * @param {number} required - number of arguments required to execute the code\n * @param {string} prefix - error message prefix\n */\nexport const reportMissing = (itemType = \"items\", found, required, prefix = \"\") => {\n  if (required !== found) {\n    const errorMessage = `Incorrect number of ${itemType}: found ${found} of ${required}`;\n    const message = prefix ? `${prefix} ${errorMessage}` : errorMessage;\n    console.error(message);\n  }\n};\n\nexport const raw = (type) => type.slice(0, -1);\n\nexport const resolveBasicType = (type) => {\n  if (wrongType(type)) return false;\n\n  if (type.includes(\"?\")) {\n    return t.Optional(t[raw(type)]);\n  }\n  return t[type];\n};\n\nexport const resolveType = (type) => {\n  if (isComplexType(type)) {\n    switch (true) {\n      case isArray(type): {\n        const arrayType = getArrayType(type);\n        return t.Array(resolveType(arrayType));\n      }\n\n      case isDictionary(type): {\n        const [key, value] = getDictionaryTypes(type);\n        return t.Dictionary({ key: resolveType(key), value: resolveType(value) });\n      }\n\n      default: {\n        return resolveBasicType(type);\n      }\n    }\n  }\n  return resolveBasicType(type);\n};\n\n/**\n * Map single argument to fcl.arg representation.\n * @param {string} type - Cadence value type\n * @param {any} value - actual value\n * @returns any - mapped fcl.arg value\n */\nexport const mapArgument = (type, value) => {\n  const resolvedType = resolveType(type);\n\n  switch (true) {\n    case isBasicType(type): {\n      return fcl.arg(value, resolvedType);\n    }\n\n    case isFixedNumType(type): {\n      // Try to parse value and throw if it fails\n      if (value === null) {\n        return fcl.arg(null, resolvedType);\n      }\n      if (isNaN(parseFloat(value))) {\n        throwTypeError(\"Expected proper value for fixed type\");\n      }\n      return fcl.arg(toFixedValue(value), resolvedType);\n    }\n\n    case isAddress(type): {\n      const prefixedAddress = withPrefix(value);\n      return fcl.arg(prefixedAddress, resolvedType);\n    }\n\n    case isArray(type): {\n      const arrayType = getArrayType(type);\n\n      if (isComplexType(arrayType)) {\n        const mappedValue = value.map((v) => mapArgument(arrayType, v).value);\n        return fcl.arg(mappedValue, resolvedType);\n      }\n\n      return fcl.arg(value, resolvedType);\n    }\n\n    case isDictionary(type): {\n      const valueType = getDictionaryTypes(type)[1];\n      const finalValue = [];\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        let resolvedValue;\n        if (isComplexType(valueType)) {\n          resolvedValue = mapArgument(valueType, value[key]);\n        } else {\n          resolvedValue = value[key];\n        }\n\n        const fixedKey = isBasicNumType(valueType) ? parseInt(key) : key\n\n        finalValue.push({\n          key: fixedKey,\n          value: resolvedValue,\n        });\n      }\n\n      return fcl.arg(finalValue, resolvedType);\n    }\n\n    default: {\n      throw `${type} is not supported`;\n    }\n  }\n};\n\nexport const assertType = (arg) => arg.xform.asArgument(arg.value);\n\n/**\n * Map arguments with provided schema.\n * @param {[string]} schema - array of Cadence value types\n * @param {[any]} values - array of passed values\n * @returns [any] - array of mapped fcl.arg values\n */\nexport const mapArguments = (schema = [], values) => {\n  if (values.length < schema.length) {\n    throw new Error(\"Not enough arguments\");\n  }\n  return values.map((value, i) => {\n    const mapped = mapArgument(schema[i], value);\n    assertType(mapped);\n    return mapped;\n  });\n};\n\n/**\n * Map arguments via Cadence template.\n * @param {string} code - Cadence template\n * @param {[any]} values - array of values\n * @returns [any] - array of mapped fcl.arg\n */\nexport const mapValuesToCode = (code, values = []) => {\n  const schema = getTemplateInfo(code).args.map(argType);\n  return mapArguments(schema, values);\n};\n\nexport const unwrap = (arr, convert) => {\n  const type = arr[arr.length - 1];\n  return arr.slice(0, -1).map((value) => convert(value, type));\n};\n\nconst rawArgs = (args) => {\n  return args.reduce((acc, arg) => {\n    const unwrapped = unwrap(arg, (value, type) => {\n      return fcl.arg(value, type);\n    });\n    acc = [...acc, ...unwrapped];\n    return acc;\n  }, []);\n};\n\nexport const resolveArguments = (args, code) => {\n  if (args.length === 0) {\n    return [];\n  }\n\n  // We can check first element in array. If it's last value is instance\n  // of @onflow/types then we assume that the rest of them are also unprocessed\n  const first = args[0];\n  if (Array.isArray(first)) {\n    const last = first[first.length - 1];\n    if (last.asArgument) {\n      return rawArgs(args);\n    }\n  }\n  // Otherwise we process them and try to match them against the code\n  return mapValuesToCode(code, args);\n};\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = (address) => {\n  if (address == null) return null;\n  return address.replace(/^0x/, \"\");\n};\n\nexport const withPrefix = (address) => {\n  if (address == null) return null;\n  return \"0x\" + sansPrefix(address);\n};\n\nexport const padAddress = (address) => {\n  return \"0x\" + sansPrefix(address).padStart(16, \"0\");\n};\n\nexport const toFixedValue = (val) => parseFloat(val).toFixed(8);\n","/*\n * Flow Template Utilities\n *\n * Copyright 2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\";\nimport { resolveArguments } from \"./args\";\nimport { replaceImportAddresses } from \"./imports\";\n\nexport const prepareInteraction = async (props, type) => {\n  const { code, cadence, args, addressMap, limit, processed } = props;\n\n  // allow to pass code via \"cadence\" field simillar to fcl.query/mutate\n  const codeTemplate = code || cadence;\n\n  const ixCode = processed ? codeTemplate : replaceImportAddresses(codeTemplate, addressMap);\n\n  const ixLimit = limit || 100;\n\n  const ix = type === \"script\" ? [fcl.script(ixCode)] : [fcl.transaction(ixCode)];\n\n  if (args) {\n    ix.push(fcl.args(resolveArguments(args, code)));\n  }\n\n  ix.push(fcl.limit(ixLimit));\n\n  if (type === \"transaction\") {\n    const { proposer, payer, signers = [] } = props;\n    const ixSigners = signers.length === 0 ? [payer] : signers;\n    const ixProposer = proposer || payer;\n\n    ix.push(fcl.payer(payer));\n    ix.push(fcl.proposer(ixProposer));\n    ix.push(fcl.authorizations(ixSigners));\n  }\n\n  return fcl.send(ix);\n};\n\n/**\n * Sends script code for execution.\n * Returns decoded value.\n */\n\nexport const executeScript = async (props) => {\n  const { raw = false } = props;\n  try {\n    const response = await prepareInteraction(props, \"script\");\n\n    // In some cases one might want to have raw output without decoding the response\n    if (raw) {\n      return [response.encodedData, null];\n    }\n\n    const decoded = await fcl.decode(response);\n    return [decoded, null];\n  } catch (e) {\n    return [null, e.message];\n  }\n};\n\nexport const waitForStatus = (statusValue) => {\n  if (typeof statusValue === \"string\") {\n    const status = statusValue.toLowerCase();\n    if (status.includes(\"final\")) {\n      return \"onceFinalized\";\n    }\n\n    if (status.includes(\"exec\")) {\n      return \"onceExecuted\";\n    }\n\n    if (status.includes(\"seal\")) {\n      return \"onceExecuted\";\n    }\n  }\n\n  // wait for transaction to be sealed by default\n  console.log(\n    `⚠️ \\x1b[33mStatus value \\x1b[1m\\x1b[35m\"${statusValue}\"\\x1b[33m\\x1b[2m is not supported. Reverting to \\x1b[32m\"onceSealed\"\\x1b[0m`\n  );\n  return \"onceSealed\";\n};\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n */\nexport const sendTransaction = async (props) => {\n  const { wait = \"seal\" } = props;\n  try {\n    const response = await prepareInteraction(props, \"transaction\");\n    if (wait) {\n      const waitMethod = waitForStatus(wait);\n      const txResult = await fcl.tx(response)[waitMethod]();\n      return [txResult, null];\n    }\n    return [response.transactionId, null];\n  } catch (e) {\n    return [null, e.message];\n  }\n};\n\n// TODO: add arguments for \"init\" method into template\nexport const addContractTemplate = `\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  `;\nexport const updateContractTemplate = `\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n`;\n\n// TODO: add jsdoc\nexport const hexContract = (contract) => Buffer.from(contract, \"utf8\").toString(\"hex\");\n\nexport const deployContract = async (props) => {\n  const {\n    name,\n    to,\n    payer,\n    proposer,\n    code: contractCode,\n    update = false,\n    processed = false,\n    addressMap = {},\n  } = props;\n\n  // Update imprort statement with addresses from addressMap\n  const ixContractCode = processed\n    ? contractCode\n    : replaceImportAddresses(contractCode, addressMap);\n\n  // TODO: Implement arguments for \"init\" method\n  const template = update ? addContractTemplate : updateContractTemplate;\n\n  const hexedCode = hexContract(ixContractCode);\n  const args = [name, hexedCode];\n  // Set roles\n  let ixProposer = to;\n  let ixPayer = to;\n  let ixSigners = [to];\n\n  if (payer) {\n    ixPayer = payer;\n    ixProposer = proposer || payer;\n  }\n\n  return sendTransaction({\n    payer: ixPayer,\n    proposer: ixProposer,\n    signers: ixSigners,\n    code: template,\n    args,\n  });\n};\n\nexport const updateContract = async (props) => {\n  return deployContract({ ...props, update: true });\n};\n"],"names":["DEPLOYED_CONTRACTS","emulator","FlowToken","FungibleToken","testnet","LockedTokens","StakingProxy","mainnet","ACCESS_NODES","getPairs","line","split","map","item","replace","filter","length","collect","acc","contract","address","extractImports","code","includes","reduce","missingImports","addressMap","importsList","missing","key","Object","prototype","hasOwnProperty","call","push","report","list","prefix","errorMessage","console","error","REGEXP_IMPORT","replaceImportAddresses","byName","match","imp","_","Function","capitalizeFirstLetter","input","first","toUpperCase","slice","getSplitCharacter","indexOf","collapseSpaces","generateSchema","argsDefinition","extract","keyWord","target","RegExp","exec","extractSigners","extractScriptArguments","extractTransactionArguments","extractContractParameters","clean","matches","Error","contractName","args","getTemplateInfo","test","signers","type","wrongType","isBasicNumType","startsWith","isArray","clearType","endsWith","isDictionary","isComplexType","splitArgs","pair","argType","getDictionaryTypes","getArrayType","resolveBasicType","t","Optional","raw","resolveType","arrayType","Array","value","Dictionary","mapArgument","resolvedType","fixedType","isString","isCharacter","isBoolean","isBasicType","fcl","arg","isFixedNumType","isNaN","parseFloat","msg","throwTypeError","toFixed","isAddress","prefixedAddress","sansPrefix","mappedValue","v","valueType","finalValue","keys","i","resolvedValue","fixedKey","parseInt","mapArguments","schema","values","mapped","xform","asArgument","mapValuesToCode","body","recover","result","e","then","prepareInteraction","props","cadence","limit","processed","codeTemplate","ixCode","ixLimit","ix","script","transaction","arr","convert","unwrap","rawArgs","resolveArguments","proposer","payer","ixSigners","ixProposer","authorizations","send","executeScript","response","encodedData","decode","decoded","message","sendTransaction","wait","transactionId","waitMethod","statusValue","status","toLowerCase","log","waitForStatus","tx","txResult","deployContract","name","to","contractCode","update","ixContractCode","template","hexedCode","Buffer","from","toString","ixPayer","singleLine","config","get","env","found","required","itemType","networkName","options","network","port","endpoint","portBased","accessNode","put","trimWith","splitBy","text","word","join"],"mappings":"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"}