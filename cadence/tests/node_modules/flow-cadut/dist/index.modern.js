import{config as e}from"@onflow/config";import*as t from"@onflow/types";import*as r from"@onflow/fcl";const n={emulator:{FlowToken:"0xee82856bf20e2aa6",FungibleToken:"0x0ae53cb6e3f42a79"},testnet:{FlowToken:"0x7e60df042a9c0868",FungibleToken:"0x9a0766d93b6608b7",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21"},mainnet:{FlowToken:"0x1654653399040a61",FungibleToken:"0xf233dcee88fe0abe",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095"}},s={mainnet:"https://access.mainnet.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},a=async()=>{const t=await e().get("ix.env")||"emulator";return n[t]||n.emulator},o=async(t="emulator",r={})=>{const a=t.toLowerCase();if(!n[a])throw new Error(`Provided value "${a}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:o,endpoint:c}=r,i=c||("emulator"===a&&o?`http://localhost:${o}`:s[a]);await e().put("ix.env",a),await e().put("accessNode.api",i)},c=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),i=(e,t)=>{const[r,n]=t;return e[r]=n,e},l=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(c).reduce(i,{}):{},u=(e,t={})=>{const r=l(e),n=[];for(const e in r)!t[e]&&Object.prototype.hasOwnProperty.call(r,e)&&n.push(e);return n},p=(e=[],t="")=>{const r="Missing imports for contracts:";console.error(t?`${t} ${r}`:r,e)},d=(e,t,r="")=>{const n=u(e,t);n.length>0&&p(n,r)},f=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,g=(e,t,r=!0)=>e.replace(f,(e,n,s,a,o)=>{const c=r?s:o;return`${n}${s} from ${(t instanceof Function?t(c):t[c])||o}`}),m=e=>{const[t]=e.split("");return t.toUpperCase()+e.slice(1)},h=e=>e.replace(/-/g,"_").split("_").map((e,t)=>t>0?m(e):e).join(""),w=(e,t,r)=>r?e.replace(t,"").split(r):e.replace(t,"").split(x(e)),x=e=>{switch(!0){case e.indexOf("//")>=0:return"//";case e.indexOf("/")>=0:return"/";case e.indexOf("\\")>=0:return"\\";default:return""}},y=e=>e.replace(/\s+/g," "),$="contract",b="transaction",k="script",v=e=>e.split(",").map(e=>e.replace(/\s*/g,"")).filter(e=>""!==e),S=(e,t)=>{const r=y(e.replace(/[\n\r]/g,""));if(r){const e=new RegExp(t,"g").exec(r);if(e)return""===e[1]?[]:v(e[1])}return[]},F=e=>S(e,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),E=e=>S(e,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),A=e=>S(e,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),W=e=>{const t=e.replace(/\r\n|\n|\r/g," "),r=/\w+\s+contract\s+(?:interface)*\s*(\w*)/g.exec(t);if(r.length<2)throw new Error("Contract Error: can't find name of the contract");return r[1]},O=e=>{const t=e.replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),r=/\w+\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(t);if(r.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:r[1],args:r[3]||""}},T=e=>{if(/transaction\s*(\(\s*\))*\s*/g.test(e)){const t=F(e),r=A(e);return{type:"transaction",signers:t.length,args:r}}if(/pub\s+fun\s+main\s*/g.test(e))return{type:"script",args:E(e)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(e)){const{contractName:t,args:r}=O(e);return{type:"contract",signers:1,args:r,contractName:t}}return{type:"unknown"}},N=e=>!e||"string"!=typeof e,C=e=>!N(e)&&(e.startsWith("Int")||e.startsWith("UInt")||e.startsWith("Word")),I=e=>{if(N(e))return!1;const t=e.replace(/\s/g,"");return t.startsWith("[")&&t.endsWith("]")},j=e=>{if(N(e))return!1;const t=e.replace(/\s/g,"");return t.startsWith("{")&&t.endsWith("}")},P=e=>I(e)||j(e),L=e=>e.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(e=>""!==e).map(e=>e.replace(/\s*/g,"")),_=e=>L(e)[1],D=e=>/{(.*)}/.exec(e)[1].split(/([^:]*):(.*)/).map(e=>e.replace(/\s/g,"")).filter(e=>e),M=e=>/\[(.*)\]/.exec(e)[1].replace(/\s+/g,""),U=(e,t,r="")=>{if(t>e){const n=`Incorrect number of arguments: found ${e} of ${t}`;console.error(r?`${r} ${n}`:n)}},z=(e="items",t,r,n="")=>{if(r!==t){const s=`Incorrect number of ${e}: found ${t} of ${r}`;console.error(n?`${n} ${s}`:s)}},B=e=>!N(e)&&(e.includes("?")?t.Optional(t[(e=>e.slice(0,-1))(e)]):t[e]),H=e=>{if(P(e))switch(!0){case I(e):{const r=M(e);return t.Array(H(r))}case j(e):{const[r,n]=D(e);return t.Dictionary({key:H(r),value:H(n)})}default:return B(e)}return B(e)},R=(e,t)=>{const n=H(e);switch(!0){case(e=>{if(N(e))return!1;let t=e.endsWith("?")?e.slice(0,-1):e;return C(t)||(e=>"String"===e)(t)||(e=>"Character"===e)(t)||(e=>"Bool"===e)(t)})(e):return r.arg(t,n);case(e=>!N(e)&&(e.startsWith("Fix64")||e.startsWith("UFix64")))(e):return null===t?r.arg(null,n):(isNaN(parseFloat(t))&&(e=>{throw new Error("Type Error: Expected proper value for fixed type")})(),r.arg(parseFloat(t).toFixed(8),n));case(e=>"Address"===e||"Address?"===e)(e):{const e=null==(s=t)?null:"0x"+(e=>null==e?null:e.replace(/^0x/,""))(s);return r.arg(e,n)}case I(e):{const s=M(e);if(P(s)){const e=t.map(e=>R(s,e).value);return r.arg(e,n)}return r.arg(t,n)}case j(e):{const s=D(e)[1],a=[],o=Object.keys(t);for(let e=0;e<o.length;e++){const r=o[e];let n;n=P(s)?R(s,t[r]):t[r];const c=C(s)?parseInt(r):r;a.push({key:c,value:n})}return r.arg(a,n)}default:throw`${e} is not supported`}var s},q=(e=[],t)=>{if(t.length<e.length)throw new Error("Not enough arguments");return t.map((t,r)=>{const n=R(e[r],t);var s;return(s=n).xform.asArgument(s.value),n})},G=(e,t=[])=>{const r=T(e).args.map(_);return q(r,t)};function J(){return(J=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}const K=async(e,t)=>{const{code:n,cadence:s,args:a,addressMap:o,limit:c,processed:i}=e,l=n||s,u=i?l:g(l,o),p=c||100,d="script"===t?[r.script(u)]:[r.transaction(u)];if(a&&d.push(r.args(((e,t)=>{if(0===e.length)return[];const n=e[0];return Array.isArray(n)&&n[n.length-1].asArgument?(e=>e.reduce((e,t)=>[...e,...((e,t)=>{const n=e[e.length-1];return e.slice(0,-1).map(e=>((e,t)=>r.arg(e,t))(e,n))})(t)],[]))(e):G(t,e)})(a,n))),d.push(r.limit(p)),"transaction"===t){const{proposer:t,payer:n,signers:s=[]}=e,a=0===s.length?[n]:s,o=t||n;d.push(r.payer(n)),d.push(r.proposer(o)),d.push(r.authorizations(a))}return r.send(d)},Q=async e=>{const{raw:t=!1}=e;try{const n=await K(e,"script");return t?[n.encodedData,null]:[await r.decode(n),null]}catch(e){return[null,e.message]}},V=async e=>{const{wait:t="seal"}=e;try{const n=await K(e,"transaction");if(t){const e=(e=>{if("string"==typeof e){const t=e.toLowerCase();if(t.includes("final"))return"onceFinalized";if(t.includes("exec"))return"onceExecuted";if(t.includes("seal"))return"onceExecuted"}return console.log(`âš ï¸ [33mStatus value [1m[35m"${e}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(t);return[await r.tx(n)[e](),null]}return[n.transactionId,null]}catch(e){return[null,e.message]}},X=async e=>{const{name:t,to:r,payer:n,proposer:s,code:a,update:o=!1,processed:c=!1,addressMap:i={}}=e,l=c?a:g(a,i),u=o?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",p=Buffer.from(l,"utf8").toString("hex");let d=r,f=r;return n&&(f=n,d=s||n),V({payer:f,proposer:d,signers:[r],code:u,args:[t,p]})},Y=async e=>X(J({},e,{update:!0}));export{$ as CONTRACT,k as SCRIPT,b as TRANSACTION,_ as argType,m as capitalizeFirstLetter,y as collapseSpaces,X as deployContract,Q as executeScript,S as extract,W as extractContractName,O as extractContractParameters,l as extractImports,E as extractScriptArguments,F as extractSigners,A as extractTransactionArguments,v as generateSchema,M as getArrayType,D as getDictionaryTypes,a as getEnvironment,x as getSplitCharacter,T as getTemplateInfo,R as mapArgument,q as mapArguments,G as mapValuesToCode,u as missingImports,V as mutate,Q as query,g as replaceImportAddresses,p as report,U as reportArguments,z as reportMissing,d as reportMissingImports,V as sendTransaction,o as setEnvironment,L as splitArgs,w as trimAndSplit,h as underscoreToCamelCase,Y as updateContract};
//# sourceMappingURL=index.modern.js.map
